<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://hypersport.club/</id><title>Hypersport</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2022-09-18T16:49:06+08:00</updated> <author> <name>Hypersport</name> <uri>https://hypersport.club/</uri> </author><link rel="self" type="application/atom+xml" href="https://hypersport.club/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://hypersport.club/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Hypersport </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Shell 常用参数</title><link href="https://hypersport.club/posts/shell-common-parameters/" rel="alternate" type="text/html" title="Shell 常用参数" /><published>2022-02-22T22:02:22+08:00</published> <updated>2022-02-22T22:02:22+08:00</updated> <id>https://hypersport.club/posts/shell-common-parameters/</id> <content src="https://hypersport.club/posts/shell-common-parameters/" /> <author> <name>hypersport</name> </author> <category term="Linux" /> <summary> 举例说明 $0 第 0 个参数，即脚本名称 $n 第 n 个参数 $# 参数个数 $@ 所有参数(每个都作为独立的字符串) $* 所有参数(作为一个字符串) ，用的不如 $@ 多 ${#@} 传递到脚本中的命令行参数的个数 ${#*} 传递到脚本中的命令行参数的个数 $? 命令执行完的返回值，0 成功，非 0 失败 $$ 脚本的进程 ID，即 PID $_ ... </summary> </entry> <entry><title>Linux 获取文件名和后缀</title><link href="https://hypersport.club/posts/get-filename-and-suffix/" rel="alternate" type="text/html" title="Linux 获取文件名和后缀" /><published>2022-02-12T22:02:12+08:00</published> <updated>2022-02-12T22:02:12+08:00</updated> <id>https://hypersport.club/posts/get-filename-and-suffix/</id> <content src="https://hypersport.club/posts/get-filename-and-suffix/" /> <author> <name>hypersport</name> </author> <category term="Linux" /> <summary> 举例说明 filename="this.is.a.sample.txt" 命令 结果 ${filename%*.} this.is.a.sample (从右向左删除第一个点右边的，非贪婪模式) ${filename%%*.} this (从右向左删除最后一个点右边的，贪婪模式) ${filenam#*.} is.a.sample.txt (从左向右删除第一个点左边的，非贪婪模式) ${filenam##*.} txt (从左向右删除最后一个点左边的，贪婪模式) </summary> </entry> <entry><title>Wget 命令</title><link href="https://hypersport.club/posts/wget-command/" rel="alternate" type="text/html" title="Wget 命令" /><published>2022-01-31T22:01:31+08:00</published> <updated>2022-09-18T16:09:41+08:00</updated> <id>https://hypersport.club/posts/wget-command/</id> <content src="https://hypersport.club/posts/wget-command/" /> <author> <name>hypersport</name> </author> <category term="Linux" /> <summary> 命令格式 wget &amp;lt;选项&amp;gt; url 常用命令选项 命令选项 解释说明 -c 继续执行上次终端的任务 -i &amp;lt;文件&amp;gt; 从指定文件获取要下载的 URL 地址 -r 递归下载 -nc 文件存在时，下载文件不覆盖原有文件 -nv 下载时只显示更新和出错信息，不显示指令的详细执行过程 -b 以后台方式运行 -q 不显示指令执行过程 -O 重命名下载文件 ... </summary> </entry> <entry><title>Tar 命令</title><link href="https://hypersport.club/posts/tar-command/" rel="alternate" type="text/html" title="Tar 命令" /><published>2022-01-18T22:01:18+08:00</published> <updated>2022-08-17T22:54:21+08:00</updated> <id>https://hypersport.club/posts/tar-command/</id> <content src="https://hypersport.club/posts/tar-command/" /> <author> <name>hypersport</name> </author> <category term="Linux" /> <summary> 常用命令选项 命令选项 解释说明 -c 或 –create 建立新的备份文件 -C &amp;lt;目录&amp;gt; 解压到指定目录 -x 或 –extract 或 –get 从备份文件中还原文件 -t 或 –list 列出备份文件的内容 -z 或 –gzip 或 –ungzip 通过 gzip 指令处理备份文件 -f &amp;lt;备份文件&amp;gt; 或 –file=&amp;lt;备份文件&amp;gt; 指定备份文件 -j 支持 bzip2 解压文件 ... </summary> </entry> <entry><title>Python 有序字典 OrderedDict</title><link href="https://hypersport.club/posts/python-ordereddict/" rel="alternate" type="text/html" title="Python 有序字典 OrderedDict" /><published>2022-01-11T22:22:22+08:00</published> <updated>2022-01-11T22:22:22+08:00</updated> <id>https://hypersport.club/posts/python-ordereddict/</id> <content src="https://hypersport.club/posts/python-ordereddict/" /> <author> <name>hypersport</name> </author> <category term="Python" /> <summary> from collections import OrderedDict d = OrderedDict() d['foo'] = 1 d['bar'] = 2 d['spam'] = 3 d['grok'] = 4 # Outputs "foo 1", "bar 2", "spam 3", "grok 4" for key in d: print(key, d[key]) # 要构建一个需要序列化或编码成其他格式的映射的时候，OrderedDict 是非常有用 import json json.dumps(d) # '{"foo": 1, "bar": 2, "spam": 3, "grok": 4}' 注意： OrderedDict 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候，它会被放到链表的尾部。对于一个已经存在的键的重复赋值不... </summary> </entry> </feed>
